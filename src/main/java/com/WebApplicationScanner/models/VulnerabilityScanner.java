package main.java.com.WebApplicationScanner.models;
import main.java.com.WebApplicationScanner.controllers.Scanner;

import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/**
 * VulnerabilityScanner aggregates multiple vulnerability scanners and
 * runs them in parallel against a target URL. It consolidates their results
 * into a single ScanResult.
 */
public class VulnerabilityScanner {

    private List<Scanner> scanners;

    /**
     * Constructs a VulnerabilityScanner with a list of Scanner implementations.
     *
     * @param scanners A list of scanners (e.g., SqlInjectionScanner, XssScanner, CsrfScanner).
     */
    public VulnerabilityScanner(List<Scanner> scanners) {
        this.scanners = scanners;
    }

    /**
     * Runs all registered vulnerability scanners concurrently on the target URL
     * and aggregates the findings into a ScanResult.
     *
     * @param targetUrl The URL to scan for vulnerabilities.
     * @return A ScanResult containing the aggregated scan outcomes.
     */
    public ScanResult runScans(String targetUrl) {
        ScanResult scanResult = new ScanResult(targetUrl);
        ExecutorService executor = Executors.newFixedThreadPool(scanners.size());

        try {
            List<Future<String>> futures = executor.invokeAll(
                scanners.stream().<Callable<String>>map(scanner -> () -> {
                    try {
                        return scanner.scan(targetUrl);
                    } catch (Exception ex) {
                        return "Error during " + scanner.getName() + " scan: " + ex.getMessage();
                    }
                }).toList()
            );

            // Process each scanner's result and update the scanResult accordingly
            for (int i = 0; i < scanners.size(); i++) {
                String result = futures.get(i).get();
                String scannerName = scanners.get(i).getName();

                // Determine vulnerability status based on result content
                if (result.contains("Detected")) {
                    switch (scannerName) {
                        case "SQL Injection Scanner":
                            scanResult.addVulnerability("SQL Injection", true, 8);
                            break;
                        case "XSS Scanner":
                            scanResult.addVulnerability("XSS", true, 7);
                            break;
                        case "CSRF Scanner":
                            scanResult.addVulnerability("CSRF", true, 6);
                            break;
                        default:
                            // For other scanners, customize as needed
                            scanResult.addVulnerability(scannerName, true, 5);
                            break;
                    }
                } else {
                    // Mark vulnerability as not detected if no indication is found
                    switch (scannerName) {
                        case "SQL Injection Scanner":
                            scanResult.addVulnerability("SQL Injection", false, 0);
                            break;
                        case "XSS Scanner":
                            scanResult.addVulnerability("XSS", false, 0);
                            break;
                        case "CSRF Scanner":
                            scanResult.addVulnerability("CSRF", false, 0);
                            break;
                        default:
                            scanResult.addVulnerability(scannerName, false, 0);
                            break;
                    }
                }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        } finally {
            executor.shutdown();
        }
        return scanResult;
    }
}
